
#===================================================================
# SAMPLEGEN 0.1
# 
# simple tool to genereate sample patterns for (mainly GLSL) shaders
#
# license is at the end of this file.
#===================================================================



import random
import math

# constants

GOLDEN_RATIO = 1.61803398875
VERSION = 0.1


# config

# type names, default is GLSL syntax
VECTOR2_TYPE_NAME =		"vec2"
VECTOR3_TYPE_NAME =		"vec3"
REAL_NUMBER_TYPE_NAME =	"float"
# custom struct type names
SAMPLEPOINT2_TYPE_NAME = "samplepoint2"
SAMPLEPOINT3_TYPE_NAME = "samplepoint3"
# wrapper macro if you need to include the files as string from c++
WRAPPER_MACRO_START =	"RDR_SHADER_TO_STRING(\n"
WRAPPER_MACRO_END =		"\n)"

TYPES_GLSL = WRAPPER_MACRO_START + """struct samplepoint2 {
	vec2 point;
	float value;
};

struct samplepoint3 {
	vec3 point;
	float value;
}; """ + WRAPPER_MACRO_END



# math

def f_rand(f): 				return random.uniform(-f, f)
def f_rand_range(f1,f2):	return random.uniform(f1, f2)
def vec2_rand(f): 			return (f_rand(f), f_rand(f))
def vec3_rand(f): 			return (f_rand(f), f_rand(f), f_rand(f))

def vec2_add(v1, v2):	return (float(v1[0]) + float(v2[0]), float(v1[1]) + float(v2[1]))
def vec3_add(v1, v2):	return (float(v1[0]) + float(v2[0]), float(v1[1]) + float(v2[1]), float(v1[2]) - float(v2[2]))
def vec2_mul_f(v, f):	return (float(v[0]) * f, float(v[1]) * f)
def vec3_mul_f(v, f):	return (float(v[0]) * f, float(v[1]) * f, v[2] * f)
def vec2_mul(v1, v2):	return (float(v1[0]) * float(v2[0]), float(v1[1]) * float(v2[1]))
def vec3_mul(v1, v2):	return (float(v1[0]) * float(v2[0]), float(v1[1]) * float(v2[1]), float(v1[2]) * float(v2[2]))
def vec2_length(v):		return (math.sqrt((float(v[0]) * float(v[0])) + (float(v[1]) * float(v[1]))))
def vec3_length(v):		return (math.sqrt((float(v[0]) * float(v[0])) + (float(v[1]) * float(v[1])) + (float(v[2]) * float(v[2]))))
def vec2_normalize(v):	return vec2_mul_f(v, 1.0 / vec2_length(v))
def vec3_normalize(v):	return vec3_mul_f(v, 1.0 / vec3_length(v))
def vec2_int(v):		return (int(v[0]), int(v[1]))
def vec3_int(v):		return (int(v[0]), int(v[1]), int(v[2]))


# serialization

def internal_vec2_str(v): 			return "{}({},\t{})".format(VECTOR2_TYPE_NAME, v[0], v[1])
def internal_vec3_str(v): 			return "{}({},\t{},\t{})".format(VECTOR3_TYPE_NAME, v[0], v[1], v[2])
def internal_samplepoint2_str(s): 	return "{}({},\t{})".format(SAMPLEPOINT2_TYPE_NAME, internal_vec2_str(s[0]), s[1])
def internal_samplepoint3_str(s): 	return "{}({},\t{})".format(SAMPLEPOINT3_TYPE_NAME, internal_vec3_str(s[0]), s[1])

def internal_fwrite(name, str):
	with open("{}.glsl".format(name), "w") as f:
		f.write(str)

def internal_arr_str(name, typename, samples, fw_func):
	str = ""
	str += "// generated by SAMPLEGEN {}\n".format(VERSION)
	str += WRAPPER_MACRO_START
	str += "// sample count = {}\n".format(len(samples))
	str += "const {} {} [{}] = ".format(typename, name, len(samples))
	str += "{\n"
	i = 0
	while(i < len(samples)):
		str += "\t"
		str += fw_func(samples[i])
		i += 1
		if(i < len(samples)):
			str += ",\n"
	str += "\n};"
	str += WRAPPER_MACRO_END
	return str

def internal_samplepoint2_fwrite(name, samples):
	return internal_fwrite(name, internal_arr_str(name, SAMPLEPOINT2_TYPE_NAME, samples, internal_samplepoint2_str))

def internal_samplepoint3_fwrite(name, samples):
	return internal_fwrite(name, internal_arr_str(name, SAMPLEPOINT3_TYPE_NAME, samples, internal_samplepoint3_str))



# pattern functions

def samplepattern_rand_inside_sphere_power(count, power):
	samples = []
	i = 0
	while(i < count):
		pos = vec2_mul_f(vec2_normalize(vec2_rand(1.0)), math.pow(f_rand_range(0.0, 1.0), power))
		samples.append((pos, f_rand_range(1.0, 2.0)))
		i = i + 1
	return samples

def samplepattern_spiral(count, power, step):
	samples = []
	i = 0
	while(i < count):
		pos = (math.cos(float(i) * step), math.sin(float(i) * step))
		val = pow(float(i) / float(count), power)
		samples.append((vec2_mul_f(pos, val), float(count - i) / float(count)))
		i = i + 1
	return samples


# main

def main():
	# write struct
	internal_fwrite("samplepoint", TYPES_GLSL) 

	rand_disc_samples = samplepattern_rand_inside_sphere_power(256, 1.2)
	spiral_samples = samplepattern_spiral(128, 0.5, 0.996)
	internal_samplepoint2_fwrite("rand_disc_samples", rand_disc_samples)
	internal_samplepoint2_fwrite("spiral_samples", spiral_samples)



if __name__ == "__main__":
	main()



#========================================================================
# LICENSE: Public Domain
#========================================================================
# This is free and unencumbered software released into the public domain.
# 
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
# 
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
# 
# For more information, please refer to <http://unlicense.org/>
#========================================================================
